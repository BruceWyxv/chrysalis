#include "FECoefficientsUserObject.h"

#include "FunctionalExpansionSolidCartesianLegendre.h"

// MOOSE includes
#include "AuxiliarySystem.h"
#include "MooseEnum.h"
#include "MooseError.h"
#include "MooseMesh.h"
#include "MooseVariable.h"

// libmesh includes
#include "libmesh/quadrature.h"

template <>
InputParameters
validParams<FECoefficientsUserObject>()
{
  InputParameters params = validParams<ElementIntegralVariableUserObject>();

  // params.addRequiredParam<UserObjectName>(
  //   "fe_coefficients_userobject",
  //   "This UserObject interacts with MooseApps through functional expansions.");
  params.addClassDescription(
    "This UserObject interacts with a MooseApp through functional expansions. "
    "\n"
    "If the MooseApp is a subclass of FunctionalExpansionAppInterface then the"
    " expansion coefficients will be pulled directly from the app itself, since"
    " the assumption is that the expansion coefficients have been generated by"
    " and loaded from an external application."
    "\n"
    "Otherwise, the inner products of the specified variable and the components"
    " of the underlying functional expansion series will be calculated to"
    " generate the expansion coefficients.");

  /*
   * An enumeration of the possible functional expansion types.
   * @Cartesian:    Legendre polynomials in x, y, and z                (default)
   * @Cylindrical:  Zernike polynomials in r and Ï•, Lengendre in z
   */
  MooseEnum FunctionalExpansionTypes("Cartesian  Cylindrical", "Cartesian");
  params.addRequiredParam<MooseEnum>("functional", FunctionalExpansionTypes, "The type of functional expansion");
  params.addRequiredParam< std::vector<unsigned int> >("orders", "The functional order to use in each dimension");
  params.addRequiredParam< std::vector<Real> >("valid_range", "The physical bounds of the functional expansion");

  params.addParam<bool>("keep_history", false, "Keep the expansion coefficients from previous solves");

  params.addParam<bool>("print_state", false, "Print the state of the zeroth instance each solve");

  return params;
}

FECoefficientsUserObject::FECoefficientsUserObject(const InputParameters & parameters)
  : ElementIntegralVariableUserObject(parameters),
    _functional_expansion_type(getParam<MooseEnum>("functional")),
    _keep_history(getParam<bool>("keep_history")),
    _orders(getParam<std::vector<unsigned int> >("orders")),
    _is_aux(_variable->kind() == Moose::VAR_AUXILIARY),
    _aux_scale(_is_aux ? calculateAuxScale(_orders.size(), _variable) : 1),
    _print_state(getParam<bool>("print_state"))
{
  if (!_keep_history)
    _coefficient_history.resize(0);

  if (_mesh.dimension() != _orders.size())
    mooseError("FECoefficientsUserObject:\n"
               "The number of requested FE orders does not match the mesh dimensionality!");
  else if (_orders.size() > 3)
    mooseError("FECoefficientsUserObject:\n"
               "Too many orders! Cannot have a dimensionality > 3.");

  if (_functional_expansion_type == "Cartesian")
  {
    auto x = _orders[0];
    auto y = _orders.size() > 1 ? _orders[1] : 0;
    auto z = _orders.size() > 2 ? _orders[2] : 0;

    _functional_expansion = new FunctionalExpansionSolidCartesianLegendre(x, y, z);
    _functional_expansion->setDimensionality(_orders.size());
  }

  std::vector<Real> valid_range = getParam< std::vector<Real> >("valid_range");
  if (valid_range.size() != _orders.size() * 2)
    mooseError("FECoefficientsUserObject:\n"
               "Mismatch between the problem dimensionality and the specified valid range for the FE.\n"
               "Both a minimum and maximum value must be provided for each dimension.");

  _functional_expansion->setBounds(valid_range);

  _coefficient_partials.resize(_functional_expansion->getNumberOfCoefficients());
}

unsigned int
FECoefficientsUserObject::calculateAuxScale(std::size_t dimensionality, const MooseVariable * /* variable */)
{
  // TODO: may need to change the hard-coded values depending on the underlying
  //       element shape of _variable
  switch (dimensionality)
  {
    case 3:
      return 8;

    case 2:
      return 4;

    case 1:
    default:
      return 2;
  }
}

Real
FECoefficientsUserObject::computeIntegral()
{
  /*
  * Loop over the quadrature points and ensure we have all the functional
  * monomials calculated and cached.
  *
  * The functional expansion classes are optimized to work with large sets of
  * quadrature points wherein one or more points share one or more coordinates.
  * Otherwise, caching the values should not increase processing overhead but
  * will impact memory usage slightly.
  */
  std::vector<const Point *> new_locations;
  for (_qp = 0; _qp < _q_point.size(); ++_qp)
    new_locations.push_back(&_q_point[_qp]);

  if (new_locations.size())
  {
    auto monomial_evaluations = _functional_expansion->expand(new_locations);

    for (unsigned int l = 0; l < new_locations.size(); ++l)
      _quadrature_monomials.emplace(*new_locations[l], monomial_evaluations[l]);
  }

  std::vector<unsigned int> locations_qp;
  for (_qp = 0; _qp < _q_point.size(); ++_qp)
    if (!_functional_expansion->isInBounds(_q_point[_qp]))
      continue;
    else
      locations_qp.push_back(_qp);

  const Real weight = _current_elem_volume * locations_qp.size() / (Real)_q_point.size();
  for (unsigned int l = 0; l < locations_qp.size(); ++l)
  {
    _qp = locations_qp[l];

    for (_c = 0; _c < _functional_expansion->getNumberOfCoefficients(); ++_c)
      if (_aux_scale)
        _coefficient_partials[_c] += weight * _aux_scale * computeQpIntegral();
      else
        _coefficient_partials[_c] += weight * computeQpIntegral();
  }

  _volume += weight;
  _quadrature_monomials.clear();

  // Return the average value
  return _coefficient_partials[0];
}

Real
FECoefficientsUserObject::computeQpIntegral()
{
  /*
   * Essentially the same as ElementIntegralVariableUserObject, but performed
   * on a coefficient basis using the pre-calculated monomials.
   */
  return _quadrature_monomials[_q_point[_qp]][_c] * ElementIntegralVariableUserObject::computeQpIntegral();
}

void
FECoefficientsUserObject::finalize()
{
  // Sum the coefficient arrays over all processes
  _communicator.sum(_coefficient_partials);
  _communicator.sum(_volume);

  for (auto & coefficient : _coefficient_partials)
    coefficient /= _volume;

  _integral_value = _coefficient_partials[0];
  _functional_expansion->setCoefficients(_coefficient_partials);

  if (_keep_history)
    _coefficient_history.push_back(_coefficient_partials);

  if (_print_state && (_current_elem->processor_id() == 0))
  {
    _console << COLOR_YELLOW << *_functional_expansion << COLOR_DEFAULT << std::endl;
  }
}

void
FECoefficientsUserObject::initialize()
{
  // Trigger the parent initialization
  ElementIntegralVariableUserObject::initialize();

  // Clear the partial sums
  for (auto & partial : _coefficient_partials)
    partial = 0;

  _volume = 0;
}

Real
FECoefficientsUserObject::spatialValue(const Point & location) const
{
  if (!_functional_expansion->isInBounds(location))
    return 0.0;

  return _functional_expansion->sample(location);
}

void
FECoefficientsUserObject::threadJoin(const UserObject & s)
{
  const FECoefficientsUserObject & sibling = static_cast<const FECoefficientsUserObject &>(s);

  for (_c = 0; _c < _coefficient_partials.size(); ++_c)
    _coefficient_partials[_c] += sibling._coefficient_partials[_c];

  _volume += sibling._volume;
}

FECoefficientsUserObject::~FECoefficientsUserObject()
{
  delete _functional_expansion;
}
