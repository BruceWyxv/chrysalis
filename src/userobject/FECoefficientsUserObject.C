#include "FECoefficientsUserObject.h"

#include "FunctionalExpansionSolidCartesianLegendre.h"

// MOOSE includes
#include "MooseEnum.h"

// libmesh includes
#include "libmesh/quadrature.h"

template <>
InputParameters
validParams<FECoefficientsUserObject>()
{
  InputParameters params = validParams<ElementIntegralVariableUserObject>();

  // params.addRequiredParam<UserObjectName>(
  //   "fe_coefficients_userobject",
  //   "This UserObject interacts with MooseApps through functional expansions.");
  params.addClassDescription(
    "This UserObject interacts with a MooseApp through functional expansions. "
    "\n"
    "If the MooseApp is a subclass of FunctionalExpansionAppInterface then the"
    " expansion coefficients will be pulled directly from the app itself, since"
    " the assumption is that the expansion coefficients have been generated by"
    " and loaded from an external application."
    "\n"
    "Otherwise, the inner products of the specified variable and the components"
    " of the underlying functional expansion series will be calculated to"
    " generate the expansion coefficients.");

  /*
   * An enumeration of the possible functional expansion types.
   * @Cartesian:    Legendre polynomials in x, y, and z                (default)
   * @Cylindrical:  Zernike polynomials in r and Ï•, Lengendre in z
   */
  MooseEnum FunctionalExpansionTypes("Cartesian  Cylindrical", "Cartesian");
  params.addRequiredParam<MooseEnum>("functional", FunctionalExpansionTypes, "The type of functional expansion");
  params.addParam< std::vector<unsigned int> >("orders", "The functional order to use in each dimension");
  params.addParam< std::vector<Real> >("boundaries", "The physical bounds of the functional expansion");

  params.addParam<bool>("keep_history", false, "Keep the expansion coefficients from previous solves");

  return params;
}

FECoefficientsUserObject::FECoefficientsUserObject(const InputParameters & parameters)
  : ElementIntegralVariableUserObject(parameters),
    _functional_expansion_type(getParam<MooseEnum>("functional")),
    _keep_history(getParam<bool>("keep_history")),
    _orders(getParam<std::vector<unsigned int> >("orders"))
{
  if (!_keep_history)
    _coefficient_history.resize(0);

  if (_functional_expansion_type == "Cartesian")
  {
    auto x = _orders[0];
    auto y = _orders.size() > 1 ? _orders[1] : 0;
    auto z = _orders.size() > 2 ? _orders[2] : 0;
    _functional_expansion = new FunctionalExpansionSolidCartesianLegendre(x, y, z);
  }
  _functional_expansion->setBounds(getParam< std::vector<Real> >("boundaries"));

  _coefficient_partials.resize(_functional_expansion->getNumberOfCoefficients());
}

Real
FECoefficientsUserObject::computeIntegral()
{
  /*
  * Loop over the quadrature points and ensure we have all the functional
  * monomials calculated and cached.
  *
  * The functional expansion classes are optimized to work with large sets of
  * quadrature points wherein one or more points share one or more coordinates.
  * Otherwise, caching the values should not increase processing overhead but
  * will impact memory usage slightly.
  */
  std::vector<unsigned int> locations_qp;
  std::vector<const Point *> new_locations;
  for (_qp = 0; _qp < _q_point.size(); ++_qp)
  {
    if (!_functional_expansion->isInBounds(&_q_point[_qp]))
    {
      _console << COLOR_RED << "Skipping point: " << _q_point[_qp] << COLOR_DEFAULT << std::endl;
      continue;
    }
    else
    {
      _console << COLOR_BLUE << "Computing integral at point: " << _q_point[_qp] << COLOR_DEFAULT << std::endl;
    }

    locations_qp.push_back(_qp);
    if (!_quadrature_monomials.count(&_q_point[_qp]))
      new_locations.push_back(&_q_point[_qp]);
  }

  if (locations_qp.size())
  {
    if (new_locations.size())
    {
      auto monomial_evaluations = _functional_expansion->expand(new_locations);
      for (unsigned int l = 0; l < new_locations.size(); ++l)
        _quadrature_monomials.emplace(new_locations[l], monomial_evaluations[l]);
    }

    // Essentially the same as ElementIntegralUserObject, but with coefficients
    for (unsigned int l = 0; l < locations_qp.size(); ++l)
    {
      _qp = locations_qp[l];

      for (_c = 0; _c < _functional_expansion->getNumberOfCoefficients(); ++_c)
        _coefficient_partials[_c] += _JxW[_qp] * _coord[_qp] * computeQpIntegral();
    }
  }

  // Return the zeroth partial sum, equivalent to the average value
  return _coefficient_partials[0];
}

Real
FECoefficientsUserObject::computeQpIntegral()
{
  /*
   * Essentially the same as ElementIntegralVariableUserObject, but performed
   * on a coefficient basis using the pre-calculated monomials.
   */
  return _quadrature_monomials[&_q_point[_qp]][_c] * ElementIntegralVariableUserObject::computeQpIntegral();
}

void
FECoefficientsUserObject::finalize()
{
  // Sum the coefficient arrays over all processes
  _communicator.sum(_coefficient_partials);
  _integral_value = _coefficient_partials[0];

  if (_keep_history)
    _coefficient_history.push_back(_coefficient_partials);

  _console << COLOR_YELLOW << " Calculated Coefficients!" << COLOR_DEFAULT << std::endl;
  _console << COLOR_YELLOW << "     Zeroth Value: " << _integral_value << COLOR_DEFAULT << std::endl;
}

void
FECoefficientsUserObject::initialize()
{
  // Trigger the parent initialization
  ElementIntegralVariableUserObject::initialize();

  // Clear the partial sums
  for (auto & partial : _coefficient_partials)
    partial = 0;
}

void
FECoefficientsUserObject::threadJoin(const UserObject & s)
{
  const FECoefficientsUserObject & sibling = static_cast<const FECoefficientsUserObject &>(s);

  for (_c = 0; _c < _coefficient_partials.size(); ++_c)
    _coefficient_partials[_c] += sibling._coefficient_partials[_c];
}

FECoefficientsUserObject::~FECoefficientsUserObject()
{
  delete _functional_expansion;
}
