#include <atomic>
#include <fstream>
#include <iostream>

#include "Function.h"

#include "SerpentExecutioner.h"
#include "SerpentTimeStepper.h"

// Include the Serpent header file
#include "header.h"
#define STR_HELPER(x) #x
#define STR(x) STR_HELPER(x)

registerMooseObject("ChrysalisApp", SerpentExecutioner);

template <>
InputParameters
validParams<SerpentExecutioner>()
{
  InputParameters params = validParams<FXExecutioner>();

  params += validParams<MutableCoefficientsInterface>();

  params.addClassDescription("Executioner for coupling to the Serpent Reactor Physics MC code");

  /*
   * Files for interfacing
   */
  params.addParam<std::string>("serpent_input",
                               "Name of the main Serpent input file to be used as a template for "
                               "creating the multiphysics interface. Namely, the communication "
                               "settings and the \"ifc ...\" lines will be appended to a duplicate "
                               "file using the name \"'serpent_input'.moose\". NOTE: this value "
                               "will be ignored if SerpentTimeStepper is explicitly defined.");
  params.addParam<std::string>("serpent_density_file",
                               "",
                               "This file will be generated by SerpentExecutioner, and is the name "
                               "of the multiphysics file that Serpent expects to find the density "
                               "coefficients in. This corresponds to the line \"ifc "
                               "'file_name'.ifc\" in the Serpent input, with an interface type of "
                               "'" STR(IFC_TYPE_FET_DENSITY) "'.");
  params.addParam<std::string>("serpent_temperature_file",
                               "",
                               "This file will be generated by SerpentExecutioner, and is the name "
                               "of the multiphysics file that Serpent expects to find the "
                               "temperature values in. This corresponds to the line \"ifc "
                               "'file_name'.ifc\" in the Serpent input, with an interface type of "
                               "'" STR(IFC_TYPE_FET_TEMP) "'.");
  params.addParam<std::string>("serpent_fission_power_file",
                               "fet",
                               "The name of the file to which Serpent should write the fission "
                               "power FETs as \"'file_name'.pwr\".");
  params.addParam<std::string>("signal_file_base",
                               ".serpent_posix",
                               "The base name of the files to be used to pass signals between "
                               "MOOSE and Serpent. The actual files will be generated from this "
                               "base name using a guaranteed unique identifier for this "
                               "Executioner instance. NOTE: this value will be ignored if "
                               "SerpentTimeStepper is explicitly defined.");
  params.addParamNamesToGroup("serpent_input serpent_density_file serpent_temperature_file "
                              "serpent_fission_power_file signal_file_base",
                              "Interface Files");

  /*
   * Serpent interface materials
   */
  params.addRequiredParam<std::string>(
      "serpent_otf_material",
      "The name of the Serpent material that will be affected on-the-fly by the exported FE.");
  params.addRequiredParam<std::string>("serpent_fission_power_outermost_material",
                                       "The outermost material of a pin structure in Serpent, used "
                                       "to identify the pin(s) where the FET power scoring should "
                                       "be performed.");
  params.addParamNamesToGroup("serpent_otf_material serpent_fission_power_outermost_material",
                              "Serpent Interface Materials");

  /*
   * Scaling of the fission power density
   */
  params.addParam<Real>(
      "average_power_level_const",
      "Average power to which the fission power density FETs should be normalized.");
  params.addParam<Real>("scale_power_level_const",
                        "Factor by which the imported Serpent FET should be scaled.");
  params.addParam<FunctionName>("average_power_level_function",
                                "A function describing the time-dependent average power to which "
                                "the fission power density FETs should be normalized.");
  params.addParam<FunctionName>("scale_power_level_function",
                                "A function describing the time-dependent value by which the "
                                "fission power density FETs should be scaled.");
  params.addParamNamesToGroup("average_power_level_const scale_power_level_const "
                              "average_power_level_function scale_power_level_function",
                              "Power Scaling");

  /*
   * Preserve history
   */
  params.addParam<bool>(
      "keep_files", false, "Keep all the files generated for manual inspection later.");

  /*
   * Parallel processing options
   */
#ifdef SERPENT_MPI_AVAILABLE
  params.addParam<long>("serpent_mpi_tasks",
                        -1,
                        "The number of MPI tasks with which to run Serpent. A value of '-1' will "
                        "default to the number of ranks in the communicator for this Executioner. "
                        "NOTE: this value will be ignored if SerpentTimeStepper is explicitly "
                        "defined.");
  params.addParamNamesToGroup("serpent_mpi_tasks", "Serpent Execution Options");
#endif // SERPENT_MPI_AVAILABLE
#ifdef SERPENT_OPENMP_AVAILABLE
  params.addParam<int>("serpent_omp_threads",
                       -1,
                       "The number of OpenMP threads with which to run Serpent. A value of '-1' "
                       "will default to the number of threads used for this MultiApp. NOTE: this "
                       "value will be ignored if SerpentTimeStepper is explicitly defined.");
  params.addParamNamesToGroup("serpent_omp_threads", "Serpent Execution Options");
#endif // SERPENT_OPENMP_AVAILABLE

  /*
   * Hide meaningless parameters from the user in this context of wraping Serpent
   */
  params.suppressParameter<unsigned int>("picard_max_its");
  params.suppressParameter<Real>("picard_rel_tol");
  params.suppressParameter<Real>("picard_abs_tol");
  params.suppressParameter<Real>("relaxation_factor");
  params.suppressParameter<std::vector<std::string>>("relaxed_variables");

  return params;
}

SerpentExecutioner::SerpentExecutioner(const InputParameters & parameters)
  : FXExecutioner(parameters),
    FunctionInterface(this),
    _serpent_interface_density_file_name(getParam<std::string>("serpent_density_file")),
    _serpent_interface_temperature_file_name(getParam<std::string>("serpent_temperature_file")),
    _serpent_otf_material(getParam<std::string>("serpent_otf_material")),
    _serpent_fission_power_outermost_material(
        getParam<std::string>("serpent_fission_power_outermost_material")),
    _serpent_interface_fission_power_density_file_name(
        getParam<std::string>("serpent_fission_power_file")),
    _keep_files(""),
    _request_fission_power_in_density_file(!_serpent_interface_density_file_name.empty()),
    _is_power_level_an_average(isParamValid("average_power_level_const") ||
                               isParamValid("average_power_level_function")),
    _is_power_level_time_varying(isParamValid("average_power_level_function") ||
                                 isParamValid("scale_power_level_function")),
    _const_power_level(_is_power_level_time_varying
                           ? -1.0
                           : (_is_power_level_an_average
                                  ? getParam<Real>("average_power_level_const")
                                  : (isParamValid("scale_power_level_const")
                                         ? getParam<Real>("average_power_level_const")
                                         : 1.0))),
    _function_power_level(
        _is_power_level_time_varying
            ? (_is_power_level_an_average
                   ? &getFunctionByName(getParam<FunctionName>("average_power_level_function"))
                   : &getFunctionByName(getParam<FunctionName>("scale_power_level_function")))
            : NULL)
{
  /*
   * Ensure sanity for the interface file names
   */
  // Ensure that a Serpent interface file was specified
  if (_serpent_interface_density_file_name.empty() &&
      _serpent_interface_temperature_file_name.empty())
    mooseError("Either \"serpent_density_file\" or \"serpent_temperature_file\" must be set!");
  // An error if both interface files are defined
  if (!_serpent_interface_density_file_name.empty() &&
      !_serpent_interface_temperature_file_name.empty())
    mooseError("Sorry, only one FE type can currently be exported. Please select only 'density' or "
               "'temperature'.");

  /*
   * Ensure sanity of the power levels
   */
  // If we are using a constant power level then ensure that it is sensible
  if (_const_power_level <= 0.0 && !_is_power_level_time_varying)
  {
    if (_is_power_level_an_average)
      paramError("average_power_level_const", "Cannot have a negative power level!");
    else
      paramError("scale_power_level_const", "Cannot have a negative power level!");
  }

  /*
   * Ensure that we don't have multiple power level specifications
   */
  // Check to see if both constant options are defined. If both are defined then we will assume that
  // the average form is preferred and flag the scale definition.
  if (isParamValid("average_power_level_const") && isParamValid("scale_power_level_const"))
    paramError("scale_power_level_const",
               "Both averaging and scaling power levels constants are defined but only one can be "
               "used. Please remove or comment-out the parameter that is not to be used.");
  // Check to see if both function options are defined. If both are defined then we will assume that
  // the average form is preferred and flag the scale definition.
  if (isParamValid("average_power_level_function") && isParamValid("scale_power_level_function"))
    paramError("scale_power_level_function",
               "Both averaging and scaling power levels functions are defined but only one can be "
               "used. Please remove or comment-out the parameter that is not to be used.");
  // Check to see if at least one constant and function are both defined. If both are defined then
  // we will assume that the function-based form is the preferred option and flag the constant.
  if (_const_power_level > 0.0 && _function_power_level)
  {
    if (isParamValid("average_power_level_const"))
    {
      if (isParamValid("average_power_level_function"))
        paramError("average_power_level_const",
                   "Both constant and function-based averaging power levels are defined but only "
                   "one can be used. Please remove of comment-out the parameter that is not to be "
                   "used.");
      else // isParamValid("scale_power_level_function")
        paramError("average_power_level_const",
                   "Both averaging constant and scaling function-based power levels are defined "
                   "but only one can be used. Please remove of comment-out the parameter that is "
                   "not to be used.");
    }
    else // isParamValid("scale_power_level_const")
    {
      if (isParamValid("average_power_level_function"))
        paramError("scale_power_level_const",
                   "Both scaling constant and averaging function-based power levels are defined "
                   "but only one can be used. Please remove of comment-out the parameter that is "
                   "not to be used.");
      else // isParamValid("scale_power_level_function")
        paramError("scale_power_level_const",
                   "Both constant and function-based scaling power levels are defined but only one "
                   "can be used. Please remove of comment-out the parameter that is not to be "
                   "used.");
    }
  }
}

void
SerpentExecutioner::init()
{
  /*
   * Generate the SerpentTimeStepper if the user didn't already define in. Most of the time the
   * default values for SerpentTimeStepper are sufficient, so defining it here is expected to be the
   * primary use case.
   */
  if (!_time_stepper.get())
  {
    /*
     * Override the default time stepper behavior here, copied from Transient
     */
    InputParameters pars = _app.getFactory().getValidParams("SerpentTimeStepper");
    pars.set<SubProblem *>("_subproblem") = &_problem;
    pars.set<FEProblemBase *>("_fe_problem_base") = &_problem;
    pars.set<Transient *>("_executioner") = this;
    if (!_pars.isParamSetByAddParam("end_time") && !_pars.isParamSetByAddParam("num_steps") &&
        _pars.isParamSetByAddParam("dt"))
      pars.set<Real>("dt") = (getParam<Real>("end_time") - getParam<Real>("start_time")) /
                             static_cast<Real>(getParam<unsigned int>("num_steps"));
    else
      pars.set<Real>("dt") = getParam<Real>("dt");
    pars.set<bool>("reset_dt") = getParam<bool>("reset_dt");

    /*
     * Add in the required file options for starting and interacting with Serpent
     */
    if (!isParamValid("serpent_input"))
      mooseError("The template file name for the main Serpent input file was not provided! Please "
                 "add a value for the parameter 'serpent_input' in the SerpentExecutioner '" +
                 name() + "'.");
    pars.set<std::string>("serpent_input") = getParam<std::string>("serpent_input");
    if (!_pars.isParamSetByAddParam("signal_file_base"))
      pars.set<std::string>("signal_file_base") = getParam<std::string>("signal_file_base");

      /*
       * Add in the parallel processing options for the Serpent executable
       */
#ifdef SERPENT_MPI_AVAILABLE
    if (!_pars.isParamSetByAddParam("serpent_mpi_tasks"))
      pars.set<long>("serpent_mpi_tasks", getParam<long>("serpent_mpi_tasks"));
#endif // SERPENT_MPI_AVAILABLE
#ifdef SERPENT_OPENMP_AVAILABLE
    if (!_pars.isParamSetByAddParam("serpent_omp_threads"))
      pars.set<int>("serpent_omp_threads", getParam<int>("serpent_omp_threads"));
#endif // SERPENT_OPENMP_AVAILABLE

    /*
     * Create the TimeStepper as in Transient::init()
     */
    _time_stepper =
        _app.getFactory().create<TimeStepper>("SerpentTimeStepper", "TimeStepper", pars);
  }
  else if (!dynamic_cast<SerpentTimeStepper *>(_time_stepper.get()))
    mooseError("In SerpentExecutioner '" + name() +
               "' an explicitly defined TimeStepper must be 'SerpentTimeStepper'");

  // Perform the rest of the default init() actions
  FXExecutioner::init();
}

void
SerpentExecutioner::exportCoefficients(const std::vector<Real> & out_coefficients)
{
  /*
   * Currently this implementation only supports either temperature or density, not both. This
   * routine will need changed later if simultaneous exports are supported.
   */
  std::string file_name;
  std::ostringstream formatter;
  std::ifstream reader;
  std::ofstream writer;

  const std::string file_base = _request_fission_power_in_density_file
                                    ? _serpent_interface_density_file_name
                                    : _serpent_interface_temperature_file_name;
  const std::string tracking = getTrackingFileNameComponent();

  // Generate the export file name and then open it for writing
  formatter.str(file_base);
  formatter << tracking << ".ifc";
  const std::string export_file_name = formatter.str();
  writer.open(export_file_name, std::ios::out | std::ios::trunc);

  /*
   * Write the basic Serpent parameters
   */
  if (!writer.is_open())
  {
    perror(("Error opening the FE export file '" + export_file_name + "'").c_str());
    mooseError();
  }
  else
  {
    // The interface type
    writer << (_request_fission_power_in_density_file ? IFC_TYPE_FET_DENSITY : IFC_TYPE_FET_TEMP);
    // The FE type
    if (_series_type_name == "Cartesian")
      writer << " " << FET_TYPE_CARTESIAN;
    else
      writer << " " << FET_TYPE_CYLINDRICAL;
    // The feedback material
    writer << " " << _serpent_otf_material;
    /* Generate an fission power density output in the pin identified by the outermost material */
    writer << " " << YES;
    writer << " " << _serpent_fission_power_outermost_material;
    writer << "\n";

    /*
     * Write the scoring parameters
     */
    // The fission power density FET file name
    writer << getFissionPowerDensityFileName();
    // Duplicate the same FE parameters for both the input and the output?
    writer << " " << YES;
    // Write out the geometry-specific FE parameters
    // clang-format off
    if (_series_type_name == "Cartesian")
    {
      //               min x                         max x                         Legendre order
      writer << " " << _physical_bounds[0] << " " << _physical_bounds[1] << " " << _orders[0]
             //        min y                         max y                         Legendre order
             << " " << _physical_bounds[2] << " " << _physical_bounds[3] << " " << _orders[1]
             //        min z                         max z                         Legendre order
             << " " << _physical_bounds[4] << " " << _physical_bounds[5] << " " << _orders[2];
    }
    else // CylindricalDuo
    {
      //               outer radius                  Zernike order
      writer << " " << _physical_bounds[4] << " " << _orders[1]
             //        axial bottom                  axial top                     Legendre order
             << " " << _physical_bounds[0] << " " << _physical_bounds[1] << " " << _orders[0]
             //        axial orientation
             << " " << (_x.isValid() ? FET_ORIENTATION_X
                              : (_y.isValid() ? FET_ORIENTATION_Y : FET_ORIENTATION_Z))
             //        axial center 1                axial center 2
             << " " << _physical_bounds[2] << " " << _physical_bounds[3];
    }
    // clang-format on
    writer << "\n";

    /*
     * Write out the exported FE coefficients
     */
    for (const auto & coefficient : out_coefficients)
      writer << coefficient << "\n";
  }

  // Close the export file
  writer.close();

  /*
   * Create the main Serpent input file as required
   */
  if (_first || _keep_files)
  {
    const SerpentTimeStepper & my_serpent_stepper = getMySerpentTimeStepper();

    // Open the template main input file
    reader.open(my_serpent_stepper.GetSerpentInputTemplateFileName());

    if (!reader.is_open())
    {
      perror(("Error opening the main Serpent template file " +
              my_serpent_stepper.GetSerpentInputTemplateFileName() + "'")
                 .c_str());
      mooseError();
    }
    else
    {
      // Open the main Serpent input file for writing
      const std::string main_file_name = my_serpent_stepper.GetSerpentInputFileName();
      writer.open(main_file_name, std::ios::out | std::ios::trunc);

      // Write the main input file
      if (!writer.is_open())
      {
        perror(("Error opening the main Serpent input file " + main_file_name + "'").c_str());
        mooseError();
      }
      else
      {
        // Copy the body of the template input file
        writer << reader.rdbuf();

        // Add in the coupling commands
        writer << "\n\n%% ==== START ==== Autogenerated multiphysics section ==== START ====\n";
        writer << "%%\tMultiphysics interface file\n";
        writer << "ifc " << export_file_name << "\n";
        writer << "\n%%\tMultiphysics signaling\n";
        writer << "set comfile " << my_serpent_stepper.GetSignalToSerpentFileName() << " "
               << my_serpent_stepper.GetSignalFromSerpentFileName() << "\n";
        writer << "\n%% ====  END  ==== Autogenerated multiphysics section ====  END  ====\n";
      }

      // Close the main input file
      writer.close();
    }

    // Close the template input file
    reader.close();
  }
}

std::string
SerpentExecutioner::getFissionPowerDensityFileName() const
{
  std::string name = _serpent_interface_fission_power_density_file_name;

  name.append(getTrackingFileNameComponent() + getMySerpentTimeStepper().GetUniqueIdentifier() +
              ".pwr");

  return name;
}

const SerpentTimeStepper &
SerpentExecutioner::getMySerpentTimeStepper() const
{
  return *(dynamic_cast<SerpentTimeStepper *>(_time_stepper.get()));
}

std::string
SerpentExecutioner::getTrackingFileNameComponent() const
{
  std::ostringstream formatter("");

  if (_keep_files)
    formatter << "_S" << _t_step << "_P" << _picard_it;

  return formatter.str();
}

void
SerpentExecutioner::importCoefficients(std::vector<Real> & array_to_fill)
{
  // Get the FET coefficients from Serpent here
  const std::string coefficient_file = getFissionPowerDensityFileName();
  Real multiplier = -1;
  std::ifstream reader;

  reader.open(coefficient_file);
  if (!reader.is_open())
  {
    perror(
        ("Error opening the fission power density output file '" + coefficient_file + "'").c_str());
    mooseError();
  }
  else
  {
    long region, first_region = -1;
    long linear_index;
    long order_1, order_2, order_3;
    Real coefficient, uncertainty;
    std::string line;

    if (getline(reader, line))       // DISCARD: header row
      if (getline(reader, line))     // DISCARD: parameters row
        if (getline(reader, line))   // DISCARD: empty line
          if (getline(reader, line)) // DISCARD: coefficient table headers
            while (reader)
            {
              reader >> region >> linear_index >> order_1 >> order_2 >> order_3 >> coefficient >>
                  uncertainty;

              // Get out of Dodge if something bad has happened
              if (reader.bad())
                break;

              // This is the first data line read, so set up any required parameters
              if (first_region < 0)
              {
                // Capture the ID of the first found region
                first_region = region;

                // Ensure the FE data is sane
                if (linear_index != 0)
                  mooseError("The first found coefficient in '%s' is not a zeroth-order "
                             "coefficient. This is very bad so we will exit now.");

                // Calculate the multiplier
                if (_is_power_level_time_varying)
                  multiplier = _function_power_level->value(_time, Point(0));
                else
                  multiplier = _const_power_level;
                // Adjust the multiplier if we are generating an average value based on the value of
                // the zeroth-order coefficient
                if (_is_power_level_an_average)
                  multiplier /= coefficient;

                _console << COLOR_BLUE << "\nMultiplying the fission power density FET by "
                         << std::setprecision(6) << multiplier << "\n"
                         << COLOR_DEFAULT << std::endl;
              }
              else if (region != first_region)
                break; // Only one region is currently supported, so exit if another region is found

              array_to_fill.push_back(coefficient * multiplier);
            }

    if (reader.bad())
    {
      perror(("Error reading from the fission power density output file '" + coefficient_file + "'")
                 .c_str());

      if (array_to_fill.size() == 0)
        mooseError("No coefficients were read from '%s'", coefficient_file);
      else
        mooseWarning("Some coefficients may not have been read from '%s'."
                     "\nAttempting to continue...",
                     coefficient_file);
    }
  }

  reader.close();
}
