#include <atomic>
#include <fstream>
#include <iostream>

#include "Function.h"

#include "SerpentExecutioner.h"
#include "SerpentTimeStepper.h"

// Include the Serpent header file
#include "header.h"
#define STR_HELPER(x) #x
#define STR(x) STR_HELPER(x)

registerMooseObject("ChrysalisApp", SerpentExecutioner);

template <>
InputParameters
validParams<SerpentExecutioner>()
{
  InputParameters params = validParams<FXExecutioner>();

  params += validParams<MutableCoefficientsInterface>();

  params.addClassDescription("Executioner for coupling to the Serpent Reactor Physics MC code");
  params.set<std::string>("_object_name", "SerpentExecutioner");

  /*
   * Files for interfacing
   */
  params.addParam<std::string>("serpent_input",
                               "Name of the main Serpent input file to be used as a template for "
                               "creating the multiphysics interface. Namely, the communication "
                               "settings and the \"ifc ...\" lines will be appended to a duplicate "
                               "file using the name \"'serpent_input'.moose\".");
  params.addParam<std::string>("serpent_density_file",
                               "",
                               "This file will be generated by SerpentExecutioner, and is the name "
                               "of the multiphysics file that Serpent expects to find the density "
                               "coefficients in. This corresponds to the line \"ifc "
                               "'file_name'.ifc\" in the Serpent input, with an interface type of "
                               "'" STR(IFC_TYPE_FET_DENSITY) "'.");
  params.addParam<std::string>("serpent_temperature_file",
                               "",
                               "This file will be generated by SerpentExecutioner, and is the name "
                               "of the multiphysics file that Serpent expects to find the "
                               "temperature values in. This corresponds to the line \"ifc "
                               "'file_name'.ifc\" in the Serpent input, with an interface type of "
                               "'" STR(IFC_TYPE_FET_TEMP) "'.");
  params.addParam<std::string>("serpent_fission_power_file",
                               "fet",
                               "The name of the file to which Serpent should write the fission "
                               "power FETs as \"'file_name'.pwr\".");
  params.addParamNamesToGroup("serpent_input serpent_density_file serpent_temperature_file "
                              "serpent_fission_power_file",
                              "Interface Files");

  /*
   * Serpent interface materials
   */
  params.addRequiredParam<std::string>(
      "serpent_otf_material",
      "The name of the Serpent material that will be affected on-the-fly by the exported FE.");
  params.addRequiredParam<std::string>("serpent_fission_power_outermost_material",
                                       "The outermost material of a pin structure in Serpent, used "
                                       "to identify the pin(s) where the FET power scoring should "
                                       "be performed.");
  params.addParamNamesToGroup("serpent_otf_material serpent_fission_power_outermost_material",
                              "Serpent Interface Materials");

  /*
   * Scaling of the fission power density
   */
  params.addParam<Real>(
      "average_power_level_const",
      "Average power to which the fission power density FETs should be normalized.");
  params.addParam<Real>("scale_power_level_const",
                        "Factor by which the imported Serpent FET should be scaled.");
  params.addParam<FunctionName>("average_power_level_function",
                                "A function describing the time-dependent average power to which "
                                "the fission power density FETs should be normalized.");
  params.addParam<FunctionName>("scale_power_level_function",
                                "A function describing the time-dependent value by which the "
                                "fission power density FETs should be scaled.");
  params.addParamNamesToGroup("average_power_level_const scale_power_level_const "
                              "average_power_level_function scale_power_level_function",
                              "Power Scaling");

  /*
   * Misc parameters
   */
  params.addParam<bool>(
      "keep_files", false, "Keep all the files generated for manual inspection later.");
  params.addParam<Real>(
      "serpent_initial_constant_fe_value",
      "The value (density fraction or temperature in K) that the initial FE to Serpent should use. "
      "In not provided, this will default to 1.0 for density fraction or 290 K for temperature.");
  params.addParamNamesToGroup("keep_files serpent_initial_constant_fe_value", "Misc");

  /*
   * Parallel processing options
   */
#ifdef SERPENT_OPENMP_AVAILABLE
  params.addParam<int>("serpent_omp_threads",
                       -1,
                       "The number of OpenMP threads with which to run Serpent. A value of '-1' "
                       "will default to the number of threads used for this MultiApp. NOTE: this "
                       "value will be ignored if SerpentTimeStepper is explicitly defined.");
  params.addParamNamesToGroup("serpent_omp_threads", "Serpent Execution Options");
#endif // SERPENT_OPENMP_AVAILABLE

  /*
   * Hide meaningless parameters from the user in this context of wraping Serpent
   */
  params.suppressParameter<unsigned int>("picard_max_its");
  params.suppressParameter<Real>("picard_rel_tol");
  params.suppressParameter<Real>("picard_abs_tol");
  params.suppressParameter<Real>("relaxation_factor");
  params.suppressParameter<std::vector<std::string>>("relaxed_variables");

  return params;
}

SerpentExecutioner::SerpentExecutioner(const InputParameters & parameters)
  : FXExecutioner(parameters),
    FunctionInterface(this),
    _serpent_interface_density_file_name(getParam<std::string>("serpent_density_file")),
    _serpent_interface_temperature_file_name(getParam<std::string>("serpent_temperature_file")),
    _serpent_initial_constant_fe_value(
        isParamValid("serpent_initial_constant_fe_value")
            ? getParam<Real>("serpent_initial_constant_fe_value")
            : (!_serpent_interface_density_file_name.empty() ? 1.0 : 290.0)),
    _serpent_otf_material(getParam<std::string>("serpent_otf_material")),
    _serpent_fission_power_outermost_material(
        getParam<std::string>("serpent_fission_power_outermost_material")),
    _serpent_input_template_file_name(getParam<std::string>("serpent_input")),
    _serpent_interface_fission_power_density_file_name(
        getParam<std::string>("serpent_fission_power_file")),
    _keep_files(""),
    _request_fission_power_in_density_file(!_serpent_interface_density_file_name.empty()),
    _is_power_level_an_average(isParamValid("average_power_level_const") ||
                               isParamValid("average_power_level_function")),
    _is_power_level_time_varying(isParamValid("average_power_level_function") ||
                                 isParamValid("scale_power_level_function")),
    _const_power_level(_is_power_level_time_varying
                           ? -1.0
                           : (_is_power_level_an_average
                                  ? getParam<Real>("average_power_level_const")
                                  : (isParamValid("scale_power_level_const")
                                         ? getParam<Real>("scale_power_level_const")
                                         : 1.0)))
{
  /*
   * Ensure sanity for the interface file names
   */
  // Ensure that a Serpent interface file was specified
  if (_serpent_interface_density_file_name.empty() &&
      _serpent_interface_temperature_file_name.empty())
    mooseError("Either \"serpent_density_file\" or \"serpent_temperature_file\" must be set!");
  // An error if both interface files are defined
  if (!_serpent_interface_density_file_name.empty() &&
      !_serpent_interface_temperature_file_name.empty())
    mooseError("Sorry, only one FE type can currently be exported. Please select only 'density' or "
               "'temperature'.");

  /*
   * Ensure sanity of the power levels
   */
  // If we are using a constant power level then ensure that it is sensible
  if (_const_power_level <= 0.0 && !_is_power_level_time_varying)
  {
    if (_is_power_level_an_average)
      paramError("average_power_level_const", "Cannot have a negative power level!");
    else
      paramError("scale_power_level_const", "Cannot have a negative power level!");
  }

  /*
   * Ensure that we don't have multiple power level specifications
   */
  // Check to see if both constant options are defined. If both are defined then we will assume that
  // the average form is preferred and flag the scale definition.
  if (isParamValid("average_power_level_const") && isParamValid("scale_power_level_const"))
    paramError("scale_power_level_const",
               "Both averaging and scaling power levels constants are defined but only one can be "
               "used. Please remove or comment-out the parameter that is not to be used.");
  // Check to see if both function options are defined. If both are defined then we will assume that
  // the average form is preferred and flag the scale definition.
  if (isParamValid("average_power_level_function") && isParamValid("scale_power_level_function"))
    paramError("scale_power_level_function",
               "Both averaging and scaling power levels functions are defined but only one can be "
               "used. Please remove or comment-out the parameter that is not to be used.");
  // Check to see if at least one constant and function are both defined. If both are defined then
  // we will assume that the function-based form is the preferred option and flag the constant.
  if (_const_power_level > 0.0 && _is_power_level_time_varying)
  {
    if (isParamValid("average_power_level_const"))
    {
      if (isParamValid("average_power_level_function"))
        paramError("average_power_level_const",
                   "Both constant and function-based averaging power levels are defined but only "
                   "one can be used. Please remove of comment-out the parameter that is not to be "
                   "used.");
      else // isParamValid("scale_power_level_function")
        paramError("average_power_level_const",
                   "Both averaging constant and scaling function-based power levels are defined "
                   "but only one can be used. Please remove of comment-out the parameter that is "
                   "not to be used.");
    }
    else // isParamValid("scale_power_level_const")
    {
      if (isParamValid("average_power_level_function"))
        paramError("scale_power_level_const",
                   "Both scaling constant and averaging function-based power levels are defined "
                   "but only one can be used. Please remove of comment-out the parameter that is "
                   "not to be used.");
      else // isParamValid("scale_power_level_function")
        paramError("scale_power_level_const",
                   "Both constant and function-based scaling power levels are defined but only one "
                   "can be used. Please remove of comment-out the parameter that is not to be "
                   "used.");
    }
  }

  // Generate the initial Serpent input files
  const std::string interface_base =
      (_request_fission_power_in_density_file ? _serpent_interface_density_file_name
                                              : _serpent_interface_temperature_file_name) +
      ".ifc";
  generateSerpentInputFile(interface_base);
  FixedSizeArray<Real> seed_coefficients(getCoefficients().size(), 0.0);
  seed_coefficients[0] = _serpent_initial_constant_fe_value;
  generateSerpentInterfaceFile(interface_base, seed_coefficients);
}

void
SerpentExecutioner::init()
{
  /*
   * Get the function pointer if needed.
   *
   * This can't be done in the initialization list because Functions haven't been constructed yet.
   */
  if (_is_power_level_time_varying)
  {
    if (_is_power_level_an_average)
      _function_power_level =
          &getFunctionByName(getParam<FunctionName>("average_power_level_function"));
    else
      _function_power_level =
          &getFunctionByName(getParam<FunctionName>("scale_power_level_function"));
  }

  /*
   * Generate the SerpentTimeStepper if the user didn't already define in. Most of the time the
   * default values for SerpentTimeStepper are sufficient, so defining it here is expected to be the
   * primary use case.
   */
  if (!_time_stepper.get())
  {
    /*
     * Override the default time stepper behavior here, copied from Transient
     */
    InputParameters pars = _app.getFactory().getValidParams("SerpentTimeStepper");
    pars.set<SubProblem *>("_subproblem") = &_problem;
    pars.set<FEProblemBase *>("_fe_problem_base") = &_problem;
    pars.set<Transient *>("_executioner") = this;
    pars.set<bool>("reset_dt") = getParam<bool>("reset_dt");

    /*
     * Add in the required file options for starting and interacting with Serpent
     */
    if (!isParamValid("serpent_input"))
      mooseError("The template file name for the main Serpent input file was not provided! Please "
                 "add a value for the parameter 'serpent_input' in the SerpentExecutioner '" +
                 name() + "'.");
    pars.set<std::string>("serpent_input") = _serpent_input_template_file_name;

    /*
     * Add in the parallel processing options for the Serpent executable
     */
#ifdef SERPENT_OPENMP_AVAILABLE
    if (!_pars.isParamSetByAddParam("serpent_omp_threads"))
      pars.set<int>("serpent_omp_threads", getParam<int>("serpent_omp_threads"));
#endif // SERPENT_OPENMP_AVAILABLE

    /*
     * Create the TimeStepper as in Transient::init()
     */
    _time_stepper =
        _app.getFactory().create<TimeStepper>("SerpentTimeStepper", "TimeStepper", pars);
  }
  else if (!dynamic_cast<SerpentTimeStepper *>(_time_stepper.get()))
    mooseError("In SerpentExecutioner '" + name() +
               "' an explicitly defined TimeStepper must be 'SerpentTimeStepper'");
  else
  {
    SerpentTimeStepper & serpent_stepper = *dynamic_cast<SerpentTimeStepper *>(_time_stepper.get());

    if (serpent_stepper.getSerpentInputTemplateFileName().empty())
      serpent_stepper.setInputFileName(_serpent_input_template_file_name);
  }

  // Perform the rest of the default init() actions
  FXExecutioner::init();
}

void
SerpentExecutioner::exportCoefficients(const FixedSizeArray<Real> & out_coefficients)
{
  /*
   * Currently this implementation only supports either temperature or density, not both. This
   * routine will need changed later if simultaneous exports are supported.
   */
  std::string file_name;
  std::ostringstream formatter;
  std::ifstream reader;
  std::ofstream writer;

  const std::string file_base = _request_fission_power_in_density_file
                                    ? _serpent_interface_density_file_name
                                    : _serpent_interface_temperature_file_name;

  // Generate the interface file name and then open it for writing
  const std::string interface_base = file_base + ".ifc";

  generateSerpentInterfaceFile(interface_base, out_coefficients);

  // Create a copy of the interface file if requested
  if (_keep_files)
  {
    reader.open(interface_base);

    if (!reader.is_open())
    {
      perror(("Error opening the interface file " + interface_base + "' for reading").c_str());
      mooseError();
    }
    else
    {
      const std::string duplicate_base = file_base + ".ifc" + getTrackingFileNameComponent();

      writer.open(duplicate_base, std::ios::trunc);
      if (!writer.is_open())
      {
        perror(("Error opening the duplicate interface file " + duplicate_base + "' for writing")
                   .c_str());
        mooseError();
      }

      // Duplicate the interface file
      writer << reader.rdbuf();

      writer.close();
    }

    reader.close();
  }
}

void
SerpentExecutioner::generateSerpentInputFile(const std::string & interface_base) const
{
  std::ifstream reader;
  std::ofstream writer;

  // Open the template main input file
  reader.open(_serpent_input_template_file_name);

  if (!reader.is_open())
  {
    perror(
        ("Error opening the main Serpent template file " + _serpent_input_template_file_name + "'")
            .c_str());
    mooseError();
  }
  else
  {
    // Open the main Serpent input file for writing
    const std::string main_file_name =
        SerpentTimeStepper::makeInputFileNameFromTemplate(_serpent_input_template_file_name);
    writer.open(main_file_name, std::ios::trunc);

    // Write the main input file
    if (!writer.is_open())
    {
      perror(("Error opening the main Serpent input file " + main_file_name + "'").c_str());
      mooseError();
    }
    else
    {
      // Copy the body of the template input file
      writer << reader.rdbuf();

      // Add in the coupling commands
      writer << "\n\n%% ==== START ==== Autogenerated multiphysics section ==== START ====\n";
      writer << "%%\tMultiphysics interface file\n";
      writer << "ifc " << interface_base << "\n";
      writer << "\n%%\tMultiphysics signaling\n";
      writer << "set comfile unused.in unused.out\n";
      writer << "set ccmaxiter 999\n";
      writer << "set power 1.0\n"; // We handle power ourselves, so do not normalize
      writer << "\n%% ====  END  ==== Autogenerated multiphysics section ====  END  ====\n";
    }

    // Close the main input file
    writer.close();
  }

  // Close the template input file
  reader.close();
}

void
SerpentExecutioner::generateSerpentInterfaceFile(
    const std::string & interface_base, const FixedSizeArray<Real> & out_coefficients) const
{
  std::ofstream writer;

  /*
   * Write the basic Serpent parameters
   */
  writer.open(interface_base, std::ios::trunc);
  if (!writer.is_open())
  {
    perror(("Error opening the FE export file '" + interface_base + "'").c_str());
    mooseError();
  }
  else
  {
    // The interface type
    writer << (_request_fission_power_in_density_file ? IFC_TYPE_FET_DENSITY : IFC_TYPE_FET_TEMP);
    // The FE type
    if (_series_type_name == "Cartesian")
      writer << " " << FET_TYPE_CARTESIAN;
    else
      writer << " " << FET_TYPE_CYLINDRICAL;
    // The feedback material
    writer << " " << _serpent_otf_material;
    /* Generate an fission power density output in the pin identified by the outermost material */
    writer << " " << YES;
    writer << " " << _serpent_fission_power_outermost_material;
    writer << "\n";

    /*
     * Write the scoring parameters
     */
    // The fission power density FET file name
    writer << getFissionPowerDensityFileName(false);
    // Duplicate the same FE parameters for both the input and the output?
    writer << " " << YES;
    // Write out the geometry-specific FE parameters
    // clang-format off
    if (_series_type_name == "Cartesian")
    {
      //               min x                         max x                         Legendre order
      writer << " " << _physical_bounds[0] << " " << _physical_bounds[1] << " " << _orders[0]
             //        min y                         max y                         Legendre order
             << " " << _physical_bounds[2] << " " << _physical_bounds[3] << " " << _orders[1]
             //        min z                         max z                         Legendre order
             << " " << _physical_bounds[4] << " " << _physical_bounds[5] << " " << _orders[2];
    }
    else // CylindricalDuo
    {
      //               outer radius                  Zernike order
      writer << " " << _physical_bounds[4] << " " << _orders[1]
             //        axial bottom                  axial top                     Legendre order
             << " " << _physical_bounds[0] << " " << _physical_bounds[1] << " " << _orders[0]
             //        axial orientation
             << " " << (_x.isValid() ? FET_ORIENTATION_X
                              : (_y.isValid() ? FET_ORIENTATION_Y : FET_ORIENTATION_Z))
             //        axial center 1                axial center 2
             << " " << _physical_bounds[2] << " " << _physical_bounds[3];
    }
    // clang-format on
    writer << "\n";

    // Check to see if all the coefficients are zero; if so, this is bad
    bool all_zero = true;
    for (std::size_t i = 0; i < out_coefficients.size(); ++i)
      if (out_coefficients[i] != 0.0)
        all_zero = false;

    // Write out the exported FE coefficients, substituting the first if necessary
    bool first = all_zero;
    for (std::size_t i = 0; i < out_coefficients.size(); ++i)
      writer << (first ? first = false, _serpent_initial_constant_fe_value : out_coefficients[i])
             << "\n";
  }

  // Close the export file
  writer.close();
}

std::string
SerpentExecutioner::getFissionPowerDensityFileName(bool generate_history_filename) const
{
  std::string name = _serpent_interface_fission_power_density_file_name;

  name.append(SerpentTimeStepper::makeMpiUnique() + ".pwr");

  if (generate_history_filename)
    name += getTrackingFileNameComponent();

  return name;
}

const SerpentTimeStepper &
SerpentExecutioner::getMySerpentTimeStepper() const
{
  return *(dynamic_cast<SerpentTimeStepper *>(_time_stepper.get()));
}

Real
SerpentExecutioner::getNormalization(const std::vector<Real> & _coefficients) const
{
  Real multiplier;

  // Calculate the multiplier
  if (_is_power_level_time_varying)
    multiplier = _function_power_level->value(_time, Point(0));
  else
    multiplier = _const_power_level;

  // Adjust the multiplier if we are generating an average value based on the value of
  // the zeroth-order coefficient
  if (_is_power_level_an_average)
    multiplier /= _coefficients[0];

#ifndef NDEBUG
  _console << COLOR_BLUE << "\nIt was calculated that multiplying the fission power density FET by "
           << std::setprecision(6) << multiplier
           << " will result in a power level with an average value of " << std::setprecision(6)
           << multiplier * _coefficients[0] << "\n"
           << COLOR_DEFAULT << std::endl;
#endif // NDEBUG

  return multiplier;
}

std::string
SerpentExecutioner::getTrackingFileNameComponent() const
{
  std::ostringstream formatter("");

  formatter << "_S" << getLocalTimeStep() << "_P" << getLocalPicardIteration();

  return formatter.str();
}

void
SerpentExecutioner::importCoefficients(FixedSizeArray<Real> & array_to_fill)
{
  // Get the FET coefficients from Serpent here
  const std::string coefficient_file = getFissionPowerDensityFileName(false);
  std::ifstream reader;

  reader.open(coefficient_file);
  if (!reader.is_open())
  {
    perror(
        ("Error opening the fission power density output file '" + coefficient_file + "'").c_str());
    mooseError();
  }
  else
  {
    long region, first_region = -1;
    long linear_index;
    long order_1, order_2, order_3;
    Real coefficient, relative_uncertainty;
    std::string line;

    if (getline(reader, line))       // DISCARD: header row
      if (getline(reader, line))     // DISCARD: parameters row
        if (getline(reader, line))   // DISCARD: empty line
          if (getline(reader, line)) // DISCARD: coefficient table headers
            while (reader)
            {
              reader >> region >> linear_index >> order_1 >> order_2 >> order_3 >> coefficient >>
                  relative_uncertainty;

              // Get out of Dodge if something bad has happened
              if (reader.bad() || reader.eof())
                break;

              // This is the first data line read, so set up any required parameters
              if (first_region < 0)
              {
                // Capture the ID of the first found region
                first_region = region;

                // Ensure the FE data is sane
                if (linear_index != 0)
                  mooseError("The first found coefficient in '%s' is not a zeroth-order "
                             "coefficient. This is very bad so we will exit now.");
              }
              else if (region != first_region)
                break; // Only one region is currently supported, so exit if another region is found

              array_to_fill[linear_index] = relative_uncertainty < 1 ? coefficient : 0.0;
            }

    if (reader.bad())
    {
      perror(("Error reading from the fission power density output file '" + coefficient_file + "'")
                 .c_str());

      if (array_to_fill.size() == 0)
        mooseError("No coefficients were read from '%s'", coefficient_file);
      else
        mooseWarning("Some coefficients may not have been read from '%s'."
                     "\nAttempting to continue...",
                     coefficient_file);
    }
  }

  reader.close();

  // Create a copy of the FET power file if requested
  if (_keep_files)
  {
    reader.open(coefficient_file);

    if (!reader.is_open())
    {
      perror(("Error opening the fission power density output file '" + coefficient_file + "'")
                 .c_str());
      mooseError();
    }
    else
    {
      std::ofstream writer;
      const std::string duplicate_base = getFissionPowerDensityFileName(true);

      writer.open(duplicate_base, std::ios::trunc);
      if (!writer.is_open())
      {
        perror(("Error opening the duplicate fission power density output file " + duplicate_base +
                "' for writing")
                   .c_str());
        mooseError();
      }

      // Duplicate the interface file
      writer << reader.rdbuf();

      writer.close();
    }

    reader.close();
  }
}

std::size_t
SerpentExecutioner::mapIndexingMooseToExternal(const std::size_t mooose_fe_index) const
{
  // The zeroth coefficients are always the same
  if (mooose_fe_index == 0)
    return 0;

  if (_series_type_name == "Cartesian")
    return mooose_fe_index; // The Cartesian indexing schema are the same for Serpent and MOOSE
  else                      // CylindricalDuo
  {
    const std::size_t legendre_terms = _orders[0] + 1;
    const std::size_t zernike_terms = (_orders[1] + 1) * (_orders[1] + 2) / 2;
    const std::size_t zernike_index = mooose_fe_index % (zernike_terms);
    const std::size_t legendre_index = (mooose_fe_index - zernike_index) / zernike_terms;

    mooseAssert(zernike_index <= zernike_terms,
                "Something bad has happened when mapping the MOOSE FE coefficient "
                    << mooose_fe_index << " to the Serpent indexing schema. A Zernike index of "
                    << zernike_index << " was calculated, but the highest possible index is "
                    << zernike_terms);
    mooseAssert(legendre_index <= legendre_terms,
                "Something bad has happened when mapping the MOOSE FE coefficient "
                    << mooose_fe_index << " to the Serpent indexing schema. A Legendre index of "
                    << legendre_index << " was calculated, but the highest possible index is "
                    << legendre_terms);

    return zernike_index * legendre_terms + legendre_index;
  }
}
