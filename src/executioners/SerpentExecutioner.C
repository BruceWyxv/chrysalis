#include <atomic>
#include <fstream>
#include <iostream>

#include "SerpentExecutioner.h"
#include "SerpentTimeStepper.h"

// Include the Serpent header file
#include "header.h"
#define STR_HELPER(x) #x
#define STR(x) STR_HELPER(x)

registerMooseObject("ChrysalisApp", SerpentExecutioner);

template <>
InputParameters
validParams<SerpentExecutioner>()
{
  InputParameters params = validParams<FXExecutioner>();

  params += validParams<MutableCoefficientsInterface>();

  params.addClassDescription("Executioner for coupling to the Serpent Reactor Physics MC code "
                             "developed at VTT, Finland");

  MooseEnum fe_types("Cartesian Cylindrical", "Cylindrical");
  std::vector<Real> empty;

  params.addParam<MooseEnum>("fe1_type", fe_types, "FE definition 1: type");
  params.addRequiredParam<std::vector<Real>>(
      "fe1_params", "FE definition 1: order and dimensions as used by Serpent");

  params.addParam<MooseEnum>("fe2_type", fe_types, "FE definition 2: function series type");
  params.addParam<std::vector<Real>>(
      "fe2_params", empty, "FE definition 2: order and dimensions as used by Serpent");

  params.addParam<MooseEnum>("fe3_type", fe_types, "FE definition 3: function series type");
  params.addParam<std::vector<Real>>(
      "fe3_params", empty, "FE definition 3: order and dimensions as used by Serpent");

  params.addParam<unsigned int>("import_fet",
                                1,
                                "Specifies which FE definition should be used for the fission "
                                "power density FET that will be produced by Serpent (defaults to "
                                "'1'). The same FE definition can be reused if appropriate.");
  params.addParam<unsigned int>("density_fe",
                                1,
                                "Specifies which FE definition should be used for the density FE "
                                "that will be exported to Serpent (defaults to '1'). The same FE "
                                "definition can be reused if appropriate.");
  params.addParam<unsigned int>("temperature_fe",
                                1,
                                "Specifies which FE definition should be used for the temperature "
                                "FE that will be exported to Serpent (defaults to '1'). The same "
                                "FE definition can be reused if appropriate.");

  params.addRequiredParam<std::string>(
      "serpent_input",
      "Name of the main Serpent input file to be used as a template for creating the multiphysics "
      "interface. Namely, the communication settings and the \"ifc 'file_name'.ifc\" line will be "
      "appended to a duplicate file using the name \"'serpent_input'.moose\".");
  params.addParam<std::string>("serpent_density_file",
                               "",
                               "This file will be generated by SerpentExecutioner, and is the name "
                               "of the multiphysics file that Serpent expects to find the density "
                               "coefficients in. This corresponds to the line \"ifc "
                               "'file_name'.ifc\" in the Serpent input, with an interface type of "
                               "'" STR(IFC_TYPE_FET_DENSITY) "'.");
  params.addParam<std::string>("serpent_temperature_file",
                               "",
                               "This file will be generated by SerpentExecutioner, and is the name "
                               "of the multiphysics file that Serpent expects to find the "
                               "temperature values in. This corresponds to the line \"ifc "
                               "'file_name'.ifc\" in the Serpent input, with an interface type of "
                               "'" STR(IFC_TYPE_FET_TEMP) "'.");
  params.addRequiredParam<std::string>(
      "serpent_otf_material",
      "The name of the Serpent material that will be affected on-the-fly by the exported FE.");
  params.addRequiredParam<std::string>("serpent_fission_power_outermost_material",
                                       "The outermost material of a pin structure in Serpent, used "
                                       "to identify the pin(s) where the FET power scoring should "
                                       "be performed.");
  params.addParam<std::string>("serpent_fission_power_file",
                               "fet",
                               "The name of the file to which Serpent should write the fission "
                               "power FETs as \"'file_name'.pwr\".");

  params.addParam<std::string>("signal_file_base",
                               ".serpent_posix",
                               "The base name of the file to be used to pass signals between MOOSE "
                               "and Serpent. The actual file will be generated from this base name "
                               "using a guaranteed unique identifier for this Executioner "
                               "instance.");

  params.addParam<Real>(
      "average_power_level_const",
      "Average power to which the fission power density FETs should be normalized.");
  params.addParam<Real>("scale_power_level_const",
                        "Factor by which the imported Serpent FET should be scaled.");
  params.addParam<FunctionName>("average_power_level_function",
                                "A function describing the time-dependent average power to which "
                                "the fission power density FETs should be normalized.");
  params.addParam<FunctionName>("scale_power_level_function",
                                "A function describing the time-dependent value by which the "
                                "fission power density FETs should be scaled.");

  params.addParam<bool>(
      "keep_files", false, "Keep all the files generated for manual inspection later.");

  return params;
}

SerpentExecutioner::SerpentExecutioner(const InputParameters & parameters)
  : FXExecutioner(parameters),
    _unique(Transient::declareRecoverableData<std::string>("unique", makeOmpMpiUnique())),
    _fe1_type(getParam<MooseEnum>("fe1_type")),
    _fe2_type(getParam<MooseEnum>("fe2_type")),
    _fe3_type(getParam<MooseEnum>("fe3_type")),
    _fe1_params(getParam<std::vector<Real>>("fe1_params")),
    _fe2_params(getParam<std::vector<Real>>("fe2_params")),
    _fe3_params(getParam<std::vector<Real>>("fe3_params")),
    _import_fet_definition_id(getParam<unsigned int>("import_fet")),
    _density_fe_definition_id(getParam<unsigned int>("density_fe")),
    _temperature_fe_definition_id(getParam<unsigned int>("temperature_fe")),
    _import_fet_params(_import_fet_definition_id == 1
                           ? _fe1_params
                           : (_import_fet_definition_id == 2 ? _fe2_params : _fe3_params)),
    _density_fe_params(_density_fe_definition_id == 1
                           ? _fe1_params
                           : (_density_fe_definition_id == 2 ? _fe2_params : _fe3_params)),
    _temperature_fe_params(_temperature_fe_definition_id == 1
                               ? _fe1_params
                               : (_temperature_fe_definition_id == 2 ? _fe2_params : _fe3_params)),
    _serpent_input_template_name(getParam<std::string>("serpent_input")),
    _serpent_interface_density_file_name(getParam<std::string>("serpent_density_file")),
    _serpent_interface_temperature_file_name(getParam<std::string>("serpent_temperature_file")),
    _serpent_otf_material(getParam<std::string>("serpent_otf_material")),
    _serpent_fission_power_outermost_material(
        getParam<std::string>("serpent_fission_power_outermost_material")),
    _serpent_interface_fission_power_density_file_name(
        getParam<std::string>("serpent_fission_power_file")),
    _posix_file_base(makePosixFileName(getParam<std::string>("signal_file_base"), _unique)),
    _keep_files(""),
    _is_power_level_an_average(isParamValid("average_power_level_const") ||
                               isParamValid("average_power_level_function")),
    _request_fission_power_in_density_file(!_serpent_interface_density_file_name.empty())
{
  if (_serpent_interface_density_file_name.empty() &&
      _serpent_interface_temperature_file_name.empty())
    mooseError("Either \"serpent_density_file\" or \"serpent_temperature_file\" must be set!");

  if (!_serpent_interface_density_file_name.empty() &&
      !_serpent_interface_temperature_file_name.empty())
    mooseError("Sorry, only one FE type can currently be exported. Please select only 'density' or "
               "'temperature'.");
}

void
SerpentExecutioner::init()
{
  // Override the default time stepper behavior here, essentially copied from Transient
  if (!_time_stepper.get())
  {
    InputParameters pars = _app.getFactory().getValidParams("SerpentTimeStepper");
    pars.set<SubProblem *>("_subproblem") = &_problem;
    pars.set<FEProblemBase *>("_fe_problem_base") = &_problem;
    pars.set<Transient *>("_executioner") = this;

    if (!_pars.isParamSetByAddParam("end_time") && !_pars.isParamSetByAddParam("num_steps") &&
        _pars.isParamSetByAddParam("dt"))
      pars.set<Real>("dt") = (getParam<Real>("end_time") - getParam<Real>("start_time")) /
                             static_cast<Real>(getParam<unsigned int>("num_steps"));
    else
      pars.set<Real>("dt") = getParam<Real>("dt");

    pars.set<bool>("reset_dt") = getParam<bool>("reset_dt");
    _time_stepper =
        _app.getFactory().create<TimeStepper>("SerpentTimeStepper", "TimeStepper", pars);
  }

  // Perform the rest of the default init() actions
  FXExecutioner::init();
}

void
SerpentExecutioner::exportCoefficients(const std::vector<Real> & out_coefficients)
{
  /*
   * Currently this implementation only supports either temperature or density, not both. This
   * routine will need changed later if simultaneous exports are supported.
   */
  std::string file_name;
  std::ostringstream formatter;
  std::ifstream reader;
  std::ofstream writer;

  const MooseEnum & type = _request_fission_power_in_density_file
                               ? getFEDefinitionType(_density_fe_definition_id)
                               : getFEDefinitionType(_temperature_fe_definition_id);
  const std::vector<Real> & params =
      _request_fission_power_in_density_file ? _density_fe_params : _temperature_fe_params;
  const std::string file_base = _request_fission_power_in_density_file
                                    ? _serpent_interface_density_file_name
                                    : _serpent_interface_temperature_file_name;
  const bool identical_fe_definitions =
      (_import_fet_definition_id == (_request_fission_power_in_density_file
                                         ? _density_fe_definition_id
                                         : _temperature_fe_definition_id));
  const std::string tracking = getTrackingFileNameComponent();

  /* Generate the export file name and then open it for writing */
  formatter.str(file_base);
  formatter << tracking << ".ifc";
  const std::string export_file_name = formatter.str();
  writer.open(export_file_name, std::ios::out | std::ios::trunc);

  /* Write the basic Serpent parameters */
  if (!writer.is_open())
  {
    perror(("Error opening the FE export file '" + export_file_name + "'").c_str());
    mooseError();
  }
  else
  {
    /* The interface type */
    writer << (_request_fission_power_in_density_file ? IFC_TYPE_FET_DENSITY : IFC_TYPE_FET_TEMP);
    /* The FE type */
    if (type == "Cartesian")
      writer << " " << FET_TYPE_CARTESIAN;
    else
      writer << " " << FET_TYPE_CYLINDRICAL;
    /* The feedback material */
    writer << " " << _serpent_otf_material;
    /* Generate an fission power density output in the pin identified by the outermost material */
    writer << " " << YES;
    writer << " " << _serpent_fission_power_outermost_material;
    writer << "\n";

    /* Write the scoring parameters */
    /* The fission power density FET file name */
    writer << getFissionPowerDensityFileName();
    /* Duplicate the same FE parameters for both the input and the output ? */
    if (identical_fe_definitions)
      writer << " " << YES;
    else
      writer << " " << NO;
    /* Write the imported FET parameters */
    for (const auto & param : _import_fet_params)
      writer << " " << param;
    writer << "\n";

    /* Write the non-identical exported parameters, if required */
    if (!identical_fe_definitions)
    {
      for (const auto & param : params)
        writer << " " << param;
      writer << "\n";
    }

    /* Write out the exported FE coefficients */
    for (const auto & coefficient : out_coefficients)
      writer << coefficient << "\n";
  }

  /* Close the export file */
  writer.close();

  /* Create the main Serpent input file as required */
  if (_first || _keep_files)
  {
    /* Open the template main input file */
    reader.open(_serpent_input_template_name);

    if (!reader.is_open())
    {
      perror(("Error opening the main Serpent template file " + _serpent_input_template_name + "'")
                 .c_str());
      mooseError();
    }
    else
    {
      /* Create the file name of the main Serpent input file then open it for writing */
      formatter.str(_serpent_input_template_name);
      formatter << _unique << ".moose";
      const std::string main_file_name = formatter.str();
      writer.open(main_file_name, std::ios::out | std::ios::trunc);

      /* Write the main input file */
      if (!writer.is_open())
      {
        perror(("Error opening the main Serpent input file " + main_file_name + "'").c_str());
        mooseError();
      }
      else
      {
        /* Copy the body of the template input file */
        writer << reader.rdbuf();

        /* Add in the coupling commands */
        writer << "\n\n%% ==== START ==== Autogenerated multiphysics section ==== START ====\n";
        writer << "%%\tMultiphysics interface file\n";
        writer << "ifc " << export_file_name << "\n";
        writer << "\n%%\tMultiphysics signaling\n";
        writer << "set comfile " << _posix_file_base << ".i " << _posix_file_base << ".o\n";
        writer << "\n%% ====  END  ==== Autogenerated multiphysics section ====  END  ====\n";
      }

      /* Close the main input file */
      writer.close();
    }

    /* Close the template input file */
    reader.close();
  }
}

const MooseEnum &
SerpentExecutioner::getFEDefinitionType(unsigned int definition)
{
  switch (definition)
  {
    case 1:
      return _fe1_type;

    case 2:
      return _fe2_type;

    case 3:
      return _fe3_type;

    default:
      mooseError("Unknown FE definition '%u', must be '1', '2', or '3'.", definition);
  }
}

std::string
SerpentExecutioner::getFissionPowerDensityFileName() const
{
  std::string name = _serpent_interface_fission_power_density_file_name;

  name.append(getTrackingFileNameComponent()).append(_unique).append(".pwr");

  return name;
}

std::string
SerpentExecutioner::getTrackingFileNameComponent() const
{
  std::ostringstream formatter("");

  if (_keep_files)
    formatter << "_S" << _t_step << "_P" << _picard_it;

  return formatter.str();
}

void
SerpentExecutioner::importCoefficients(std::vector<Real> & array_to_fill)
{
  // Get the FET coefficients from Serpent here
  const std::string coefficient_file = getFissionPowerDensityFileName();
  std::ifstream reader;

  reader.open(coefficient_file);
  if (!reader.is_open())
  {
    perror(
        ("Error opening the fission power density output file '" + coefficient_file + "'").c_str());
    mooseError();
  }
  else
  {
    long region, first_region = -1;
    long linear_index;
    long order_1, order_2, order_3;
    Real coefficient, uncertainty;
    std::string line;

    if (getline(reader, line))       // DISCARD: header row
      if (getline(reader, line))     // DISCARD: parameters row
        if (getline(reader, line))   // DISCARD: empty line
          if (getline(reader, line)) // DISCARD: coefficient table headers
            while (reader)
            {
              reader >> region >> linear_index >> order_1 >> order_2 >> order_3 >> coefficient >>
                  uncertainty;

              // Get out of Dodge if something bad has happened
              if (reader.bad())
                break;

              // Only one region is currently supported, so skip any other regions
              if (first_region < 0)
                first_region = region;
              else if (region != first_region)
                break;

              array_to_fill.push_back(coefficient);
            }

    if (reader.bad())
    {
      perror(("Error reading from the fission power density output file '" + coefficient_file + "'")
                 .c_str());

      if (array_to_fill.size() == 0)
        mooseError("No coefficients were read from '%s'", coefficient_file);
      else
        mooseWarning("Some coefficients may not have been read from '%s'."
                     "\nAttempting to continue...",
                     coefficient_file);
    }
  }

  reader.close();
}

std::string
SerpentExecutioner::makeOmpMpiUnique()
{
  static std::atomic<uint64_t> id;
  const uint64_t next_id = id++;

  int rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  std::ostringstream formatter("");
  formatter << ".o" << next_id << ".m" << rank;

  return formatter.str();
}

std::string
SerpentExecutioner::makePosixFileName(const std::string & file_base, const std::string & unique)
{
  std::string file_name(file_base);

  file_name.append(unique);

  return file_name;
}
